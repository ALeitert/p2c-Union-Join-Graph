#include "mstEdges.h"


// Helper function for checkAllEdges().
// Computes, for a given vertex u and all vertices v, the largest minimum edge weight of all paths from u to v.
vector<int> maxMinWeights(size_t startId)
{
    // Assume we are given a vertex u.
    // For all v, we want to compute the largest minimum edge weight of all paths from u to v.
    // That is: max_P min_xy wei(xy)

    // Note that Dijkstra's algorithm solves a similar problem.
    // The distance between two vertices is the smallest sum of edges of all paths.
    // That is: min_P sum_xy wei(xy)

    // We therefore use a very similar algorithm.
    // We start with Dikstra's algorithm and make the following changes:
    //  1) We relax an edge xy as follows if d(y) < min(d(x), wei(uv)) then d(y) := min(d(x), wei(uv))
    //     We use < because min_P, and min() because min_xy.
    //  2) As next vertex to process, we pick the vertex with largest d().

    // We can show the correctnes of our approach with the same technique one uses to prove Dijkstra's algorithm.
    // Let v be the next vertex to pick (i.e., with largest d()).
    // Claim: d() is optimal for v.
    // Proof: Assume there is a differen path P leading to a better d(v).
    // Let P = s ~> x -> y ~> v where xy is edge on boundry (i.e., we processed x and can pick y).
    // Note that d(y) <= d(v).
    // Hence, there is an edge e in s ~> y with wei(e) <= d(v).
    // Subsequently, min_P <= wei(e) < d(v).

    return vector<int>();
}

// Determines all edges which are part of a MaxST by checking each edge individually.
vector<sizePair> checkAllEdges(const Graph& g)
{
    throw runtime_error("Not implemented.");


    // Consider an edge uv with weigth w.

    // --- Theorem ---
    // There is a MaxST T that contains uv if and only if
    // there is no path from u to v where each edge weight is strictly larger than w
    // (== all path contain an edge with weight <= w).

    // Proof (outline):
    // -->  Assume uv is part of some MaxST T and there is such a path P.
    //      Each edge P then has a larger weight, and one such edge xy is not part of T.
    //      Hence, T'created by removing uv and adding xy has a larger total weight than T.
    //
    // <--  Assume there is no such path and T is a MaxST not containing uv.
    //      Let P be the path from u to v in T.
    //      P contains and edge xy with weight <= w.
    //      Let T' be tree generated by removing xy and adding uv.
    //      Then wei(T') >= wei(T), since wei(uv) >= wei(xy).


    // --- Approach ---

    // 'There is no path from u to v where each edge weight is strictly larger than w.'
    // == not [  exist P = u ~> v:  forall xy in P:   wei(xy) >  w ]
    // ==       forall P = u ~> v:   exist xy in P:   wei(xy) <= w
    // ==       forall P = u ~> v:   min_{ xy in P }  wei(xy) <= w
    // ==        max_{ P = u ~> v }  min_{ xy in P }  wei(xy) <= w
    // == 'The largest minimum edge weight of all paths is at most w.'

    // We simplify the statement as follows: max_P min_xy wei(xy) <= w.

    // Our goal now is to compute the largest minimum edge weight of all paths and all pairs uv.
    // The function maxMinWeights(u) computes that for a given u and all vertices v.

    // We now compute all edges that are part of a MaxST as follows:
    // For each vertex u, let A[] = maxMinWeights(u).
    // For each neighbour v of u, if A[v] <= wei(uv), add uv to result.

    return vector<sizePair>();
}
